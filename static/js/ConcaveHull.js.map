{"mappings":"C,A,S,C,C,C,C,C,C,C,C,C,E,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,A,Y,O,C,C,E,E,C,C,E,C,E,E,K,E,C,E,E,A,a,O,Q,A,Y,O,O,O,E,O,O,C,I,C,Q,S,E,C,C,C,E,G,C,C,C,E,C,C,G,C,C,C,E,C,C,I,E,A,Y,O,C,C,E,E,C,C,E,C,G,C,G,E,O,E,E,C,G,G,E,O,E,E,C,G,G,G,A,U,O,E,O,E,G,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,O,C,S,C,E,I,E,C,C,E,C,E,C,E,C,O,A,M,E,E,C,E,E,K,C,C,E,I,E,C,C,E,C,I,E,M,C,G,C,C,E,C,E,C,I,C,E,O,C,E,E,E,O,C,E,C,O,C,C,E,C,O,C,S,E,C,E,I,E,E,O,C,G,M,A,C,I,E,C,E,E,E,C,C,E,e,C,C,E,E,M,C,S,C,E,I,C,E,C,E,I,C,M,C,E,I,C,O,C,C,C,E,E,O,C,E,E,K,C,E,E,M,C,E,E,Q,C,S,C,C,C,E,C,C,E,C,C,S,C,C,C,E,E,O,C,C,E,C,E,A,E,O,c,C,E,O,C,I,W,O,C,C,E,A,C,G,C,C,E,C,E,I,I,E,E,E,E,M,C,I,E,C,C,E,E,G,E,C,I,E,E,E,A,C,U,O,S,A,a,O,O,O,O,C,E,Y,O,Q,O,G,E,O,W,O,C,E,C,E,C,Q,C,S,C,C,C,C,C,C,C,E,A,E,kD,iB,C,GCkCwE,EAAO,OAAO,CAAuR,AAAW,CAAA,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,EAAJ,KAAA,EAA0C,GAAG,CAAC,GAAG,EAAE,OAAO,EAAE,EAAE,CAAC,GAAG,GAAG,EAAE,OAAO,EAAE,EAAE,CAAC,GAAG,IAAI,EAAE,AAAI,MAAM,uBAAuB,EAAE,IAAK,OAAM,EAAE,IAAI,CAAC,mBAAmB,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,IAA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","sources":["<anon>","rescript/ConcaveHull.js","node_modules/@parcel/transformer-js/src/esmodule-helpers.js"],"sourcesContent":["// modules are defined as an array\n// [ module function, map of requires ]\n//\n// map of requires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the require for previous bundles\n\n(function (modules, entry, mainEntry, parcelRequireName, globalName) {\n  /* eslint-disable no-undef */\n  var globalObject =\n    typeof globalThis !== 'undefined'\n      ? globalThis\n      : typeof self !== 'undefined'\n      ? self\n      : typeof window !== 'undefined'\n      ? window\n      : typeof global !== 'undefined'\n      ? global\n      : {};\n  /* eslint-enable no-undef */\n\n  // Save the require from previous bundle to this closure if any\n  var previousRequire =\n    typeof globalObject[parcelRequireName] === 'function' &&\n    globalObject[parcelRequireName];\n\n  var cache = previousRequire.cache || {};\n  // Do not use `require` to prevent Webpack from trying to bundle this call\n  var nodeRequire =\n    typeof module !== 'undefined' &&\n    typeof module.require === 'function' &&\n    module.require.bind(module);\n\n  function newRequire(name, jumped) {\n    if (!cache[name]) {\n      if (!modules[name]) {\n        // if we cannot find the module within our internal map or\n        // cache jump to the current global require ie. the last bundle\n        // that was added to the page.\n        var currentRequire =\n          typeof globalObject[parcelRequireName] === 'function' &&\n          globalObject[parcelRequireName];\n        if (!jumped && currentRequire) {\n          return currentRequire(name, true);\n        }\n\n        // If there are other bundles on this page the require from the\n        // previous one is saved to 'previousRequire'. Repeat this as\n        // many times as there are bundles until the module is found or\n        // we exhaust the require chain.\n        if (previousRequire) {\n          return previousRequire(name, true);\n        }\n\n        // Try the node require function if it exists.\n        if (nodeRequire && typeof name === 'string') {\n          return nodeRequire(name);\n        }\n\n        var err = new Error(\"Cannot find module '\" + name + \"'\");\n        err.code = 'MODULE_NOT_FOUND';\n        throw err;\n      }\n\n      localRequire.resolve = resolve;\n      localRequire.cache = {};\n\n      var module = (cache[name] = new newRequire.Module(name));\n\n      modules[name][0].call(\n        module.exports,\n        localRequire,\n        module,\n        module.exports,\n        globalObject\n      );\n    }\n\n    return cache[name].exports;\n\n    function localRequire(x) {\n      var res = localRequire.resolve(x);\n      return res === false ? {} : newRequire(res);\n    }\n\n    function resolve(x) {\n      var id = modules[name][1][x];\n      return id != null ? id : x;\n    }\n  }\n\n  function Module(moduleName) {\n    this.id = moduleName;\n    this.bundle = newRequire;\n    this.exports = {};\n  }\n\n  newRequire.isParcelRequire = true;\n  newRequire.Module = Module;\n  newRequire.modules = modules;\n  newRequire.cache = cache;\n  newRequire.parent = previousRequire;\n  newRequire.register = function (id, exports) {\n    modules[id] = [\n      function (require, module) {\n        module.exports = exports;\n      },\n      {},\n    ];\n  };\n\n  Object.defineProperty(newRequire, 'root', {\n    get: function () {\n      return globalObject[parcelRequireName];\n    },\n  });\n\n  globalObject[parcelRequireName] = newRequire;\n\n  for (var i = 0; i < entry.length; i++) {\n    newRequire(entry[i]);\n  }\n\n  if (mainEntry) {\n    // Expose entry point to Node, AMD or browser globals\n    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js\n    var mainExports = newRequire(mainEntry);\n\n    // CommonJS\n    if (typeof exports === 'object' && typeof module !== 'undefined') {\n      module.exports = mainExports;\n\n      // RequireJS\n    } else if (typeof define === 'function' && define.amd) {\n      define(function () {\n        return mainExports;\n      });\n\n      // <script>\n    } else if (globalName) {\n      this[globalName] = mainExports;\n    }\n  }\n})({\"1BcfJ\":[function(require,module,exports,__globalThis) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\n// Generated by ReScript, PLEASE EDIT WITH CARE\n/*\n==== License Information ====\nCopyright (c) 2014-2024, Andrii Heonia\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the name of the author nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n==== License Information ====\n*/ (function(f) {\n    var g;\n    module.exports = f();\n})(function() {\n    var define, module1, exports;\n    return (function() {\n        function r(e, n, t) {\n            function o(i, f) {\n                if (!n[i]) {\n                    if (!e[i]) {\n                        var c = undefined;\n                        if (!f && c) return c(i, !0);\n                        if (u) return u(i, !0);\n                        var a = new Error(\"Cannot find module '\" + i + \"'\");\n                        throw a.code = \"MODULE_NOT_FOUND\", a;\n                    }\n                    var p = n[i] = {\n                        exports: {}\n                    };\n                    e[i][0].call(p.exports, function(r) {\n                        var n = e[i][1][r];\n                        return o(n || r);\n                    }, p, p.exports, r, e, n, t);\n                }\n                return n[i].exports;\n            }\n            for(var u = undefined, i = 0; i < t.length; i++)o(t[i]);\n            return o;\n        }\n        return r;\n    })()({\n        1: [\n            function(require1, module1, exports) {\n                function _cross(o, a, b) {\n                    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\n                }\n                function _upperTangent(pointset) {\n                    const lower = [];\n                    for(let l = 0; l < pointset.length; l++){\n                        while(lower.length >= 2 && _cross(lower[lower.length - 2], lower[lower.length - 1], pointset[l]) <= 0)lower.pop();\n                        lower.push(pointset[l]);\n                    }\n                    lower.pop();\n                    return lower;\n                }\n                function _lowerTangent(pointset) {\n                    const reversed = pointset.reverse(), upper = [];\n                    for(let u = 0; u < reversed.length; u++){\n                        while(upper.length >= 2 && _cross(upper[upper.length - 2], upper[upper.length - 1], reversed[u]) <= 0)upper.pop();\n                        upper.push(reversed[u]);\n                    }\n                    upper.pop();\n                    return upper;\n                }\n                // pointset has to be sorted by X\n                function convex(pointset) {\n                    const upper = _upperTangent(pointset), lower = _lowerTangent(pointset);\n                    const convex = lower.concat(upper);\n                    convex.push(pointset[0]);\n                    return convex;\n                }\n                module1.exports = convex;\n            },\n            {}\n        ],\n        2: [\n            function(require1, module1, exports) {\n                module1.exports = {\n                    toXy: function(pointset, format) {\n                        if (format === undefined) return pointset.slice();\n                        return pointset.map(function(pt) {\n                            /*jslint evil: true */ const _getXY = new Function('pt', 'return [pt' + format[0] + ',' + 'pt' + format[1] + '];');\n                            return _getXY(pt);\n                        });\n                    },\n                    fromXy: function(pointset, format) {\n                        if (format === undefined) return pointset.slice();\n                        return pointset.map(function(pt) {\n                            /*jslint evil: true */ const _getObj = new Function('pt', 'const o = {}; o' + format[0] + '= pt[0]; o' + format[1] + '= pt[1]; return o;');\n                            return _getObj(pt);\n                        });\n                    }\n                };\n            },\n            {}\n        ],\n        3: [\n            function(require1, module1, exports) {\n                function Grid(points, cellSize) {\n                    this._cells = [];\n                    this._cellSize = cellSize;\n                    this._reverseCellSize = 1 / cellSize;\n                    for(let i = 0; i < points.length; i++){\n                        const point = points[i];\n                        const x = this.coordToCellNum(point[0]);\n                        const y = this.coordToCellNum(point[1]);\n                        if (!this._cells[x]) {\n                            const array = [];\n                            array[y] = [\n                                point\n                            ];\n                            this._cells[x] = array;\n                        } else if (!this._cells[x][y]) this._cells[x][y] = [\n                            point\n                        ];\n                        else this._cells[x][y].push(point);\n                    }\n                }\n                Grid.prototype = {\n                    cellPoints: function(x, y) {\n                        return this._cells[x] !== undefined && this._cells[x][y] !== undefined ? this._cells[x][y] : [];\n                    },\n                    rangePoints: function(bbox) {\n                        const tlCellX = this.coordToCellNum(bbox[0]);\n                        const tlCellY = this.coordToCellNum(bbox[1]);\n                        const brCellX = this.coordToCellNum(bbox[2]);\n                        const brCellY = this.coordToCellNum(bbox[3]);\n                        const points = [];\n                        for(let x = tlCellX; x <= brCellX; x++){\n                            for(let y = tlCellY; y <= brCellY; y++)// replaced Array.prototype.push.apply to avoid hitting stack size limit on larger arrays.\n                            for(let i = 0; i < this.cellPoints(x, y).length; i++)points.push(this.cellPoints(x, y)[i]);\n                        }\n                        return points;\n                    },\n                    removePoint: function(point) {\n                        const cellX = this.coordToCellNum(point[0]);\n                        const cellY = this.coordToCellNum(point[1]);\n                        const cell = this._cells[cellX][cellY];\n                        let pointIdxInCell;\n                        for(let i = 0; i < cell.length; i++)if (cell[i][0] === point[0] && cell[i][1] === point[1]) {\n                            pointIdxInCell = i;\n                            break;\n                        }\n                        cell.splice(pointIdxInCell, 1);\n                        return cell;\n                    },\n                    trunc: Math.trunc || function(val) {\n                        return val - val % 1;\n                    },\n                    coordToCellNum: function(x) {\n                        return this.trunc(x * this._reverseCellSize);\n                    },\n                    extendBbox: function(bbox, scaleFactor) {\n                        return [\n                            bbox[0] - scaleFactor * this._cellSize,\n                            bbox[1] - scaleFactor * this._cellSize,\n                            bbox[2] + scaleFactor * this._cellSize,\n                            bbox[3] + scaleFactor * this._cellSize\n                        ];\n                    }\n                };\n                function grid(points, cellSize) {\n                    return new Grid(points, cellSize);\n                }\n                module1.exports = grid;\n            },\n            {}\n        ],\n        4: [\n            function(require1, module1, exports) {\n                'use strict';\n                const intersect = require1('./intersect.js');\n                const grid = require1('./grid.js');\n                const formatUtil = require1('./format.js');\n                const convexHull = require1('./convex.js');\n                function _filterDuplicates(pointset) {\n                    const unique = [\n                        pointset[0]\n                    ];\n                    let lastPoint = pointset[0];\n                    for(let i = 1; i < pointset.length; i++){\n                        const currentPoint = pointset[i];\n                        if (lastPoint[0] !== currentPoint[0] || lastPoint[1] !== currentPoint[1]) unique.push(currentPoint);\n                        lastPoint = currentPoint;\n                    }\n                    return unique;\n                }\n                function _sortByX(pointset) {\n                    return pointset.sort(function(a, b) {\n                        return a[0] - b[0] || a[1] - b[1];\n                    });\n                }\n                function _sqLength(a, b) {\n                    return Math.pow(b[0] - a[0], 2) + Math.pow(b[1] - a[1], 2);\n                }\n                function _cos(o, a, b) {\n                    const aShifted = [\n                        a[0] - o[0],\n                        a[1] - o[1]\n                    ], bShifted = [\n                        b[0] - o[0],\n                        b[1] - o[1]\n                    ], sqALen = _sqLength(o, a), sqBLen = _sqLength(o, b), dot = aShifted[0] * bShifted[0] + aShifted[1] * bShifted[1];\n                    return dot / Math.sqrt(sqALen * sqBLen);\n                }\n                function _intersect(segment, pointset) {\n                    for(let i = 0; i < pointset.length - 1; i++){\n                        const seg = [\n                            pointset[i],\n                            pointset[i + 1]\n                        ];\n                        if (segment[0][0] === seg[0][0] && segment[0][1] === seg[0][1] || segment[0][0] === seg[1][0] && segment[0][1] === seg[1][1]) continue;\n                        if (intersect(segment, seg)) return true;\n                    }\n                    return false;\n                }\n                function _occupiedArea(pointset) {\n                    let minX = Infinity;\n                    let minY = Infinity;\n                    let maxX = -Infinity;\n                    let maxY = -Infinity;\n                    for(let i = pointset.length - 1; i >= 0; i--){\n                        if (pointset[i][0] < minX) minX = pointset[i][0];\n                        if (pointset[i][1] < minY) minY = pointset[i][1];\n                        if (pointset[i][0] > maxX) maxX = pointset[i][0];\n                        if (pointset[i][1] > maxY) maxY = pointset[i][1];\n                    }\n                    return [\n                        maxX - minX,\n                        maxY - minY // height\n                    ];\n                }\n                function _bBoxAround(edge) {\n                    return [\n                        Math.min(edge[0][0], edge[1][0]),\n                        Math.min(edge[0][1], edge[1][1]),\n                        Math.max(edge[0][0], edge[1][0]),\n                        Math.max(edge[0][1], edge[1][1]) // bottom\n                    ];\n                }\n                function _midPoint(edge, innerPoints, convex) {\n                    let point = null, angle1Cos = MAX_CONCAVE_ANGLE_COS, angle2Cos = MAX_CONCAVE_ANGLE_COS, a1Cos, a2Cos;\n                    for(let i = 0; i < innerPoints.length; i++){\n                        a1Cos = _cos(edge[0], edge[1], innerPoints[i]);\n                        a2Cos = _cos(edge[1], edge[0], innerPoints[i]);\n                        if (a1Cos > angle1Cos && a2Cos > angle2Cos && !_intersect([\n                            edge[0],\n                            innerPoints[i]\n                        ], convex) && !_intersect([\n                            edge[1],\n                            innerPoints[i]\n                        ], convex)) {\n                            angle1Cos = a1Cos;\n                            angle2Cos = a2Cos;\n                            point = innerPoints[i];\n                        }\n                    }\n                    return point;\n                }\n                function _concave(convex, maxSqEdgeLen, maxSearchArea, grid, edgeSkipList) {\n                    let midPointInserted = false;\n                    for(let i = 0; i < convex.length - 1; i++){\n                        const edge = [\n                            convex[i],\n                            convex[i + 1]\n                        ];\n                        // generate a key in the format X0,Y0,X1,Y1\n                        const keyInSkipList = edge[0][0] + ',' + edge[0][1] + ',' + edge[1][0] + ',' + edge[1][1];\n                        if (_sqLength(edge[0], edge[1]) < maxSqEdgeLen || edgeSkipList.has(keyInSkipList)) continue;\n                        let scaleFactor = 0;\n                        let bBoxAround = _bBoxAround(edge);\n                        let bBoxWidth;\n                        let bBoxHeight;\n                        let midPoint;\n                        do {\n                            bBoxAround = grid.extendBbox(bBoxAround, scaleFactor);\n                            bBoxWidth = bBoxAround[2] - bBoxAround[0];\n                            bBoxHeight = bBoxAround[3] - bBoxAround[1];\n                            midPoint = _midPoint(edge, grid.rangePoints(bBoxAround), convex);\n                            scaleFactor++;\n                        }while (midPoint === null && (maxSearchArea[0] > bBoxWidth || maxSearchArea[1] > bBoxHeight));\n                        if (bBoxWidth >= maxSearchArea[0] && bBoxHeight >= maxSearchArea[1]) edgeSkipList.add(keyInSkipList);\n                        if (midPoint !== null) {\n                            convex.splice(i + 1, 0, midPoint);\n                            grid.removePoint(midPoint);\n                            midPointInserted = true;\n                        }\n                    }\n                    if (midPointInserted) return _concave(convex, maxSqEdgeLen, maxSearchArea, grid, edgeSkipList);\n                    return convex;\n                }\n                function hull(pointset, concavity, format) {\n                    let maxEdgeLen = concavity || 20;\n                    const points = _filterDuplicates(_sortByX(formatUtil.toXy(pointset, format)));\n                    if (points.length < 4) {\n                        const concave = points.concat([\n                            points[0]\n                        ]);\n                        return format ? formatUtil.fromXy(concave, format) : concave;\n                    }\n                    const occupiedArea = _occupiedArea(points);\n                    const maxSearchArea = [\n                        occupiedArea[0] * MAX_SEARCH_BBOX_SIZE_PERCENT,\n                        occupiedArea[1] * MAX_SEARCH_BBOX_SIZE_PERCENT\n                    ];\n                    const convex = convexHull(points);\n                    const innerPoints = points.filter(function(pt) {\n                        return convex.indexOf(pt) < 0;\n                    });\n                    const cellSize = Math.ceil(1 / (points.length / (occupiedArea[0] * occupiedArea[1])));\n                    const concave = _concave(convex, Math.pow(maxEdgeLen, 2), maxSearchArea, grid(innerPoints, cellSize), new Set());\n                    return format ? formatUtil.fromXy(concave, format) : concave;\n                }\n                const MAX_CONCAVE_ANGLE_COS = Math.cos(90 / (180 / Math.PI)); // angle = 90 deg\n                const MAX_SEARCH_BBOX_SIZE_PERCENT = 0.6;\n                module1.exports = hull;\n            },\n            {\n                \"./convex.js\": 1,\n                \"./format.js\": 2,\n                \"./grid.js\": 3,\n                \"./intersect.js\": 5\n            }\n        ],\n        5: [\n            function(require1, module1, exports) {\n                function ccw(x1, y1, x2, y2, x3, y3) {\n                    const cw = (y3 - y1) * (x2 - x1) - (y2 - y1) * (x3 - x1);\n                    return cw > 0 ? true : cw < 0 ? false : true; // colinear\n                }\n                function intersect(seg1, seg2) {\n                    const x1 = seg1[0][0], y1 = seg1[0][1], x2 = seg1[1][0], y2 = seg1[1][1], x3 = seg2[0][0], y3 = seg2[0][1], x4 = seg2[1][0], y4 = seg2[1][1];\n                    return ccw(x1, y1, x3, y3, x4, y4) !== ccw(x2, y2, x3, y3, x4, y4) && ccw(x1, y1, x2, y2, x3, y3) !== ccw(x1, y1, x2, y2, x4, y4);\n                }\n                module1.exports = intersect;\n            },\n            {}\n        ]\n    }, {}, [\n        4\n    ])(4);\n});\n /*  Not a pure module */ \n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"jBTt3\"}],\"jBTt3\":[function(require,module,exports,__globalThis) {\nexports.interopDefault = function(a) {\n    return a && a.__esModule ? a : {\n        default: a\n    };\n};\nexports.defineInteropFlag = function(a) {\n    Object.defineProperty(a, '__esModule', {\n        value: true\n    });\n};\nexports.exportAll = function(source, dest) {\n    Object.keys(source).forEach(function(key) {\n        if (key === 'default' || key === '__esModule' || Object.prototype.hasOwnProperty.call(dest, key)) return;\n        Object.defineProperty(dest, key, {\n            enumerable: true,\n            get: function() {\n                return source[key];\n            }\n        });\n    });\n    return dest;\n};\nexports.export = function(dest, destName, get) {\n    Object.defineProperty(dest, destName, {\n        enumerable: true,\n        get: get\n    });\n};\n\n},{}]},[\"1BcfJ\"], \"1BcfJ\", \"parcelRequire94c2\")\n\n//# sourceMappingURL=ConcaveHull.js.map\n","// Generated by ReScript, PLEASE EDIT WITH CARE\n\n\n/*\n==== License Information ====\nCopyright (c) 2014-2024, Andrii Heonia\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the name of the author nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n==== License Information ====\n*/\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.hull = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\nfunction _cross(o, a, b) {\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\n}\n\nfunction _upperTangent(pointset) {\n    const lower = [];\n    for (let l = 0; l < pointset.length; l++) {\n        while (lower.length >= 2 && (_cross(lower[lower.length - 2], lower[lower.length - 1], pointset[l]) <= 0)) {\n            lower.pop();\n        }\n        lower.push(pointset[l]);\n    }\n    lower.pop();\n    return lower;\n}\n\nfunction _lowerTangent(pointset) {\n    const reversed = pointset.reverse(),\n        upper = [];\n    for (let u = 0; u < reversed.length; u++) {\n        while (upper.length >= 2 && (_cross(upper[upper.length - 2], upper[upper.length - 1], reversed[u]) <= 0)) {\n            upper.pop();\n        }\n        upper.push(reversed[u]);\n    }\n    upper.pop();\n    return upper;\n}\n\n// pointset has to be sorted by X\nfunction convex(pointset) {\n    const upper = _upperTangent(pointset),\n          lower = _lowerTangent(pointset);\n    const convex = lower.concat(upper);\n    convex.push(pointset[0]);  \n    return convex;  \n}\n\nmodule.exports = convex;\n\n},{}],2:[function(require,module,exports){\nmodule.exports = {\n\n    toXy: function(pointset, format) {\n        if (format === undefined) {\n            return pointset.slice();\n        }\n        return pointset.map(function(pt) {\n            /*jslint evil: true */\n            const _getXY = new Function('pt', 'return [pt' + format[0] + ',' + 'pt' + format[1] + '];');\n            return _getXY(pt);\n        });\n    },\n\n    fromXy: function(pointset, format) {\n        if (format === undefined) {\n            return pointset.slice();\n        }\n        return pointset.map(function(pt) {\n            /*jslint evil: true */\n            const _getObj = new Function('pt', 'const o = {}; o' + format[0] + '= pt[0]; o' + format[1] + '= pt[1]; return o;');\n            return _getObj(pt);\n        });\n    }\n\n}\n},{}],3:[function(require,module,exports){\nfunction Grid(points, cellSize) {\n    this._cells = [];\n    this._cellSize = cellSize;\n    this._reverseCellSize = 1 / cellSize;\n\n    for (let i = 0; i < points.length; i++) {\n        const point = points[i];\n        const x = this.coordToCellNum(point[0]);\n        const y = this.coordToCellNum(point[1]);\n        if (!this._cells[x]) {\n            const array = [];\n            array[y] = [point];\n            this._cells[x] = array;\n        } else if (!this._cells[x][y]) {\n            this._cells[x][y] = [point];\n        } else {\n            this._cells[x][y].push(point);\n        }\n    }\n}\n\nGrid.prototype = {\n    cellPoints: function(x, y) { // (Number, Number) -> Array\n        return (this._cells[x] !== undefined && this._cells[x][y] !== undefined) ? this._cells[x][y] : [];\n    },\n\n    rangePoints: function(bbox) { // (Array) -> Array\n        const tlCellX = this.coordToCellNum(bbox[0]);\n        const tlCellY = this.coordToCellNum(bbox[1]);\n        const brCellX = this.coordToCellNum(bbox[2]);\n        const brCellY = this.coordToCellNum(bbox[3]);\n        const points = [];\n\n        for (let x = tlCellX; x <= brCellX; x++) {\n            for (let y = tlCellY; y <= brCellY; y++) {\n                // replaced Array.prototype.push.apply to avoid hitting stack size limit on larger arrays.\n                for (let i = 0; i < this.cellPoints(x, y).length; i++) {\n                    points.push(this.cellPoints(x, y)[i]);\n                }\n            }\n        }\n\n        return points;\n    },\n\n    removePoint: function(point) { // (Array) -> Array\n        const cellX = this.coordToCellNum(point[0]);\n        const cellY = this.coordToCellNum(point[1]);\n        const cell = this._cells[cellX][cellY];\n        let pointIdxInCell;\n\n        for (let i = 0; i < cell.length; i++) {\n            if (cell[i][0] === point[0] && cell[i][1] === point[1]) {\n                pointIdxInCell = i;\n                break;\n            }\n        }\n\n        cell.splice(pointIdxInCell, 1);\n\n        return cell;\n    },\n\n    trunc: Math.trunc || function(val) { // (number) -> number\n        return val - val % 1;\n    },\n\n    coordToCellNum: function(x) { // (number) -> number\n        return this.trunc(x * this._reverseCellSize);\n    },\n\n    extendBbox: function(bbox, scaleFactor) { // (Array, Number) -> Array\n        return [\n            bbox[0] - (scaleFactor * this._cellSize),\n            bbox[1] - (scaleFactor * this._cellSize),\n            bbox[2] + (scaleFactor * this._cellSize),\n            bbox[3] + (scaleFactor * this._cellSize)\n        ];\n    }\n};\n\nfunction grid(points, cellSize) {\n    return new Grid(points, cellSize);\n}\n\nmodule.exports = grid;\n},{}],4:[function(require,module,exports){\n'use strict';\n\nconst intersect = require('./intersect.js');\nconst grid = require('./grid.js');\nconst formatUtil = require('./format.js');\nconst convexHull = require('./convex.js');\n\nfunction _filterDuplicates(pointset) {\n    const unique = [pointset[0]];\n    let lastPoint = pointset[0];\n    for (let i = 1; i < pointset.length; i++) {\n        const currentPoint = pointset[i];\n        if (lastPoint[0] !== currentPoint[0] || lastPoint[1] !== currentPoint[1]) {\n            unique.push(currentPoint);\n        }\n        lastPoint = currentPoint;\n    }\n    return unique;\n}\n\nfunction _sortByX(pointset) {\n    return pointset.sort(function(a, b) {\n        return (a[0] - b[0]) || (a[1] - b[1]);\n    });\n}\n\nfunction _sqLength(a, b) {\n    return Math.pow(b[0] - a[0], 2) + Math.pow(b[1] - a[1], 2);\n}\n\nfunction _cos(o, a, b) {\n    const aShifted = [a[0] - o[0], a[1] - o[1]],\n        bShifted = [b[0] - o[0], b[1] - o[1]],\n        sqALen = _sqLength(o, a),\n        sqBLen = _sqLength(o, b),\n        dot = aShifted[0] * bShifted[0] + aShifted[1] * bShifted[1];\n\n    return dot / Math.sqrt(sqALen * sqBLen);\n}\n\nfunction _intersect(segment, pointset) {\n    for (let i = 0; i < pointset.length - 1; i++) {\n        const seg = [pointset[i], pointset[i + 1]];\n        if (segment[0][0] === seg[0][0] && segment[0][1] === seg[0][1] ||\n            segment[0][0] === seg[1][0] && segment[0][1] === seg[1][1]) {\n            continue;\n        }\n        if (intersect(segment, seg)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction _occupiedArea(pointset) {\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    for (let i = pointset.length - 1; i >= 0; i--) {\n        if (pointset[i][0] < minX) {\n            minX = pointset[i][0];\n        }\n        if (pointset[i][1] < minY) {\n            minY = pointset[i][1];\n        }\n        if (pointset[i][0] > maxX) {\n            maxX = pointset[i][0];\n        }\n        if (pointset[i][1] > maxY) {\n            maxY = pointset[i][1];\n        }\n    }\n\n    return [\n        maxX - minX, // width\n        maxY - minY  // height\n    ];\n}\n\nfunction _bBoxAround(edge) {\n    return [\n        Math.min(edge[0][0], edge[1][0]), // left\n        Math.min(edge[0][1], edge[1][1]), // top\n        Math.max(edge[0][0], edge[1][0]), // right\n        Math.max(edge[0][1], edge[1][1])  // bottom\n    ];\n}\n\nfunction _midPoint(edge, innerPoints, convex) {\n    let point = null,\n        angle1Cos = MAX_CONCAVE_ANGLE_COS,\n        angle2Cos = MAX_CONCAVE_ANGLE_COS,\n        a1Cos, a2Cos;\n\n    for (let i = 0; i < innerPoints.length; i++) {\n        a1Cos = _cos(edge[0], edge[1], innerPoints[i]);\n        a2Cos = _cos(edge[1], edge[0], innerPoints[i]);\n\n        if (a1Cos > angle1Cos && a2Cos > angle2Cos &&\n            !_intersect([edge[0], innerPoints[i]], convex) &&\n            !_intersect([edge[1], innerPoints[i]], convex)) {\n\n            angle1Cos = a1Cos;\n            angle2Cos = a2Cos;\n            point = innerPoints[i];\n        }\n    }\n\n    return point;\n}\n\nfunction _concave(convex, maxSqEdgeLen, maxSearchArea, grid, edgeSkipList) {\n    let midPointInserted = false;\n\n    for (let i = 0; i < convex.length - 1; i++) {\n        const edge = [convex[i], convex[i + 1]];\n        // generate a key in the format X0,Y0,X1,Y1\n        const keyInSkipList = edge[0][0] + ',' + edge[0][1] + ',' + edge[1][0] + ',' + edge[1][1];\n\n        if (_sqLength(edge[0], edge[1]) < maxSqEdgeLen ||\n            edgeSkipList.has(keyInSkipList)) { continue; }\n\n        let scaleFactor = 0;\n        let bBoxAround = _bBoxAround(edge);\n        let bBoxWidth;\n        let bBoxHeight;\n        let midPoint;\n        do {\n            bBoxAround = grid.extendBbox(bBoxAround, scaleFactor);\n            bBoxWidth = bBoxAround[2] - bBoxAround[0];\n            bBoxHeight = bBoxAround[3] - bBoxAround[1];\n\n            midPoint = _midPoint(edge, grid.rangePoints(bBoxAround), convex);\n            scaleFactor++;\n        }  while (midPoint === null && (maxSearchArea[0] > bBoxWidth || maxSearchArea[1] > bBoxHeight));\n\n        if (bBoxWidth >= maxSearchArea[0] && bBoxHeight >= maxSearchArea[1]) {\n            edgeSkipList.add(keyInSkipList);\n        }\n\n        if (midPoint !== null) {\n            convex.splice(i + 1, 0, midPoint);\n            grid.removePoint(midPoint);\n            midPointInserted = true;\n        }\n    }\n\n    if (midPointInserted) {\n        return _concave(convex, maxSqEdgeLen, maxSearchArea, grid, edgeSkipList);\n    }\n\n    return convex;\n}\n\nfunction hull(pointset, concavity, format) {\n    let maxEdgeLen = concavity || 20;\n\n    const points = _filterDuplicates(_sortByX(formatUtil.toXy(pointset, format)));\n\n    if (points.length < 4) {\n        const concave = points.concat([points[0]]);\n        return format ? formatUtil.fromXy(concave, format) : concave;\n    }\n\n    const occupiedArea = _occupiedArea(points);\n    const maxSearchArea = [\n        occupiedArea[0] * MAX_SEARCH_BBOX_SIZE_PERCENT,\n        occupiedArea[1] * MAX_SEARCH_BBOX_SIZE_PERCENT\n    ];\n\n    const convex = convexHull(points);\n    const innerPoints = points.filter(function(pt) {\n        return convex.indexOf(pt) < 0;\n    });\n\n    const cellSize = Math.ceil(1 / (points.length / (occupiedArea[0] * occupiedArea[1])));\n\n    const concave = _concave(\n        convex, Math.pow(maxEdgeLen, 2),\n        maxSearchArea, grid(innerPoints, cellSize), new Set());\n\n    return format ? formatUtil.fromXy(concave, format) : concave;\n}\n\nconst MAX_CONCAVE_ANGLE_COS = Math.cos(90 / (180 / Math.PI)); // angle = 90 deg\nconst MAX_SEARCH_BBOX_SIZE_PERCENT = 0.6;\n\nmodule.exports = hull;\n\n},{\"./convex.js\":1,\"./format.js\":2,\"./grid.js\":3,\"./intersect.js\":5}],5:[function(require,module,exports){\nfunction ccw(x1, y1, x2, y2, x3, y3) {           \n    const cw = ((y3 - y1) * (x2 - x1)) - ((y2 - y1) * (x3 - x1));\n    return cw > 0 ? true : cw < 0 ? false : true; // colinear\n}\n\nfunction intersect(seg1, seg2) {\n  const x1 = seg1[0][0], y1 = seg1[0][1],\n      x2 = seg1[1][0], y2 = seg1[1][1],\n      x3 = seg2[0][0], y3 = seg2[0][1],\n      x4 = seg2[1][0], y4 = seg2[1][1];\n\n    return ccw(x1, y1, x3, y3, x4, y4) !== ccw(x2, y2, x3, y3, x4, y4) && ccw(x1, y1, x2, y2, x3, y3) !== ccw(x1, y1, x2, y2, x4, y4);\n}\n\nmodule.exports = intersect;\n},{}]},{},[4])(4)\n});\n;\n\nexport {\n  \n}\n/*  Not a pure module */\n","exports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {default: a};\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (\n      key === 'default' ||\n      key === '__esModule' ||\n      Object.prototype.hasOwnProperty.call(dest, key)\n    ) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get,\n  });\n};\n"],"names":["modules","entry","mainEntry","parcelRequireName","globalName","globalObject","globalThis","self","window","global","previousRequire","cache","nodeRequire","module","require","bind","newRequire","name","jumped","currentRequire","err","Error","code","localRequire","resolve","x","id","Module","call","exports","res","isParcelRequire","moduleName","bundle","parent","register","Object","defineProperty","get","i","length","mainExports","define","amd","__globalThis","parcelHelpers","defineInteropFlag","r","e","n","t","o","f","c","undefined","u","a","p","require1","module1","_cross","b","pointset","upper","_upperTangent","lower","l","pop","push","convex","_lowerTangent","reversed","reverse","concat","toXy","format","slice","map","pt","_getXY","Function","fromXy","_getObj","Grid","points","cellSize","_cells","_cellSize","_reverseCellSize","point","coordToCellNum","y","array","prototype","cellPoints","rangePoints","bbox","tlCellX","tlCellY","brCellX","brCellY","removePoint","pointIdxInCell","cellX","cellY","cell","splice","trunc","Math","val","extendBbox","scaleFactor","intersect","grid","formatUtil","convexHull","_sqLength","pow","_cos","aShifted","bShifted","sqALen","dot","sqrt","_intersect","segment","seg","MAX_CONCAVE_ANGLE_COS","cos","PI","concavity","_filterDuplicates","unique","lastPoint","currentPoint","sort","concave","occupiedArea","_occupiedArea","minX","Infinity","minY","maxX","maxY","maxSearchArea","innerPoints","filter","indexOf","_concave","maxSqEdgeLen","edgeSkipList","midPointInserted","bBoxWidth","bBoxHeight","midPoint","edge","keyInSkipList","has","bBoxAround","min","max","_midPoint","angle1Cos","angle2Cos","a1Cos","a2Cos","add","ceil","Set","ccw","x1","y1","x2","y2","x3","y3","cw","seg1","seg2","x4","y4","interopDefault","__esModule","default","value","exportAll","source","dest","keys","forEach","key","hasOwnProperty","enumerable","export","destName"],"version":3,"file":"ConcaveHull.js.map"}